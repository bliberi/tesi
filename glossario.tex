
%**************************************************************
% Acronimi
%**************************************************************
\renewcommand{\acronymname}{Acronimi e abbreviazioni}

\newacronym{uml}{UML}{Unified Modeling Language}

\newacronym{ampl}{AMPL}{A Mathematical Programming Language}

\newacronym{ide}{IDE}{Integrated Developement Environment}

\newacronym{gui}{GUI}{Graphical User Interface}
%**************************************************************
% Glossario
%**************************************************************
\renewcommand{\glossaryname}{Glossario}

\newglossaryentry{umlg}
{
    name=\glslink{uml}{UML},
    text=UML,
    sort=uml,
    description={in ingegneria del software \emph{UML, Unified Modeling Language} (ing. linguaggio di modellazione unificato) è un linguaggio di modellazione e specifica basato sul paradigma object-oriented. L'\emph{UML} svolge un'importantissima funzione di ``lingua franca'' nella comunità della progettazione e programmazione a oggetti. Gran parte della letteratura di settore usa tale linguaggio per descrivere soluzioni analitiche e progettuali in modo sintetico e comprensibile a un vasto pubblico}
}

\newglossaryentry{probsched}
{
    name=Problema di Schedulazione/Scheduling,
    text=problemi di scheduling,
    sort=problemi di scheduling,
    description={Un problema di schedulazione definisce le variabili decisionali, una regione ammissibile entro la quale le variabili decisionali possono variare e una funzione obiettivo per determinare la migliore \emph{\gls{sched}}\glsfirstoccur\ ammissibile}
}

\newglossaryentry{sched}
{
    name=Schedulazione/Scheduling,
    text=schedulazione,
    sort=schedulazione,
    description={La schedulazione è una forma di processo decisionale che consiste nell'allocare risorse finite in modo tale che un dato obiettivo venga ottimizzato, sincronizzando e tempificando la sequenza delle operazioni}
}

\newglossaryentry{metodo-esatto}
{
    name=Metodo esatto,
    text=metodo esatto,
    sort=metodo esatto,
    description={I metodi di risoluzione dei problemi di ottimizzazione combinatoria ricadono in due categorie: i metodi esatti e metodi euristici (vd. \textit{Algoritmo euristico}). I primi sono metodi che riescono a fornire una soluzione ottima, a differenza dei secondi che riescono a fornire una soluzione ammissibile ma senza la garanzia che sia ottimale \cite{degio:dispensa}.
    Esempi di algoritmi esatti sono il simplesso o il branch-and-bound}
}

\newglossaryentry{algeur}
{
    name=Algoritmo euristico,
    text=euristici,
    sort=algoritmo euristico,
    description={I metodi di risoluzione dei problemi di ottimizzazione combinatoria ricadono in due categorie: i metodi esatti (vd. \textit{Metodo esatto}) e metodi euristici. In matematica e informatica un metodo euristico è un particolare tipo di algoritmo progettato per risolvere un problema di ricerca operativa più velocemente (qualora i metodi esatti siano troppo lenti) o per trovare una soluzione approssimata (qualora i metodi esatti falliscano nel trovare una soluzione esatta). Il risultato viene ottenuto cercando di equilibrare ottimalità, completezza, accuratezza e velocità di esecuzione. \\
    Possono essere applicati quando la soluzione è data selezionando il miglior sottoinsieme di un dato insieme di elementi e sono costruttivi, ovvero partono da una soluzione vuota e ad ogni iterazione aggiungono un elemento applicando dei criteri di selezione \cite{degio:dispensa}}
}

\newglossaryentry{greedy}
{
    name=Algoritmo Greedy,
    text=greedy,
    sort=algoritmo greedy,
    description={Un algoritmo greedy è un algoritmo euristico che ad ogni iterazione compie una scelta ``golosa'', ovvero la migliore (in termini di impatto sulla funzione obiettivo) da prendere in quel momento}
}

\newglossaryentry{meteur}
{
    name=Meta-euristica,
    text=meta-euristici,
    sort=meta-euristica,
    description={In matematica e informatica è una strategia per esplorare in maniera efficiente lo spazio delle soluzioni per trovare delle soluzioni vicine all'ottimo e scappare dagli ottimi locali. Non sono algoritmi costruttivi e necessitano quindi di una soluzione per poterne trovarne un'altra migliore}
}

\newglossaryentry{tabu}
{
    name=Tabu Search,
    text=Tabu Search,
    sort=Tabu Search,
    description={La Tabu Search è una tecnica meta-euristica utilizzata per la soluzione di numerosi problemi di ottimizzazione, tra cui problemi di scheduling. Essa consiste nel partire da una soluzione iniziale ed eseguire una serie di ``mosse'' che portano ad una nuova soluzione all'interno del vicinato per la quale la funzione obiettivo f assume un valore migliore del valore attuale. Per sfuggire gli ottimi locali, la Tabu Search permette un certo numero di mosse peggioranti rendendo tabù, proibite, le ultime mosse eseguite per evitare di ``tornare indietro''}
}

\newglossaryentry{supply-chain}
{
    name=Supply chain,
    text=supply chain,
    sort=supply chain,
    description={La supply chain (in italiano, ``catena di distribuzione'') è il sistema di organizzazioni, persone, attività, informazioni e risorse coinvolte nel portare un prodotto o un servizio dal fornitore al cliente}
}

\newglossaryentry{dummy}
{
    name=Dummy worker,
    text=Dummy Worker,
    sort=dummy worker,
    description={Nel campo degli algoritmi euristici e dei problemi di scheduling, aggiungere un Dummy Worker è una tecnica usata per produrre sempre una soluzione ammissibile, anche quando in realtà l'algoritmo euristico non riesce a trovarne una. Il Dummy Worker può essere assegnato senza alcun vincolo a qualsiasi \task\ durante qualsiasi \ttb, tuttavia inserirlo introduce una penalità altissima per la funzione obiettivo, di conseguenza viene introdotto in uno schedule quando non c'è nessun'altra alternativa. Nello schedule finale, il numero di \task\ non assegnati corrisponde al numero di \task\ assegnati al Dummy Worker}
}


\newglossaryentry{nphard}
{
    name=NP-Hard,
    text=NP-Hard,
    sort=nphard,
    description={vd. \emph{\gls{teoria-compl}}\glsfirstoccur}
}

\newglossaryentry{teoria-compl}
{
    name=Teoria della complessità computazionale,
    text=teoria della complessità computazionale,
    sort=teoria,
    description={In informatica, la teoria della complessità computazionale è una branca della teoria della computabilità che studia le risorse minime necessarie (principalmente tempo di calcolo e memoria) per la risoluzione di un problema. I problemi sono classificati in differenti classi di complessità, in base all'efficienza del migliore algoritmo noto in grado di risolvere quello specifico problema:
    \begin{itemize}
        \item $\mathcal{P}$ (\textit{Polynomial-time problems}) - Contiene tutti i problemi decisionali che possono essere risolti da una macchina di Turing deterministica in tempo polinomiale. La classe $\mathcal{P}$ può essere caratterizzata come quella classe di problemi per i quali si è in grado di trovare una soluzione in tempo polinomiale.
        \item $\mathcal{NP}$ (\textit{Nondeterministic polynomial-time problems}) - Contiene tutti i problemi decisionali che possono essere risolti da una macchina di Turing non deterministica in tempo polinomiale. La classe $\mathcal{NP}$ può essere caratterizzata come quella classe di problemi per i quali non si è in grado di trovare una soluzione in tempo polinomiale, ma si è in grado di verificare se una possibile soluzione è effettivamente tale in tempo polinomiale. \\ In particolare, $\mathcal{P} \subseteq\ \mathcal{NP}$.
        \item $\mathcal{NP-C}$ o NP-Completi - Sono i più difficili problemi nella classe $\mathcal{NP}$: se si trovasse un algoritmo in grado di risolvere in tempo polinomiale un qualsiasi problema in $\mathcal{NP-C}$, allora si potrebbe usarlo per risolvere in tempo polinomiale ogni problema in $\mathcal{NP}$. \\ In particolare, $\mathcal{NP-C} \subseteq\ \mathcal{NP}$.
        \item $\mathcal{H}$ o NP-Hard (\textit{Nondeterministic polynomial-time hard problems}) -  Classe di problemi (non limitata ai soli problemi di decisione, ma estesa anche ai problemi di ottimizzazione, ad esempio) che può essere definita informalmente come la classe dei problemi non meno difficili dei problemi $\mathcal{NP-C}$, che a loro volta sono per definizione i più difficili della classe $\mathcal{NP}$. Si noti che non è sempre vero che $\mathcal{H} \subseteq\ \mathcal{NP}$.
    \end{itemize}
    \cite{wiki:teoria-compl}
    }
}

\newglossaryentry{framework}
{
    name=Framework,
    text=framework,
    sort=framework,
    description={Nello sviluppo software, il framework è un'architettura logica di supporto su cui un software può essere progettato e realizzato; la sua funzione è quella di creare una infrastruttura generale, lasciando al programmatore il contenuto vero e proprio dell'applicazione}
}

\newglossaryentry{amplg}
{
    name=\gls{ampl},
    text=AMPL,
    sort=ampl,
    description={È un linguaggio ad alto livello per descrivere e risolvere grossi e complicati problemi di programmazione matematica (per esempio problemi di ottimizzazione e di scheduling)}
}

\newglossaryentry{ideg}
{
    name=\gls{ide},
    text=IDE,
    sort=ide,
    description={È un software che, in fase di programmazione, aiuta il programmatore nello sviluppo del codice sorgente fornendo un controllo sintassi in tempo reale e una serie di strumenti e funzionalità di supporto allo sviluppo e al debugging}
}

\newglossaryentry{drive}
{
    name=Google Drive,
    text=Google Drive,
    sort=google drive,
    description={Servizio fornito da Google in ambiente cloud computing che offre funzioni di condivisione e hosting di file, permettendone la modifica collaborativa su uno spazio gratuito di 15 GB}
}

\newglossaryentry{repository}
{
    name=Repository,
    text=repository,
    sort=repository,
    description={Ambiente di un sistema informativo in cui vengono gestiti i metadati attraverso tabelle relazionali. L'insieme di tabelle, regole e motori di calcolo tramite cui si gestiscono i metadati prende il nome di metabase}
}

\newglossaryentry{git}
{
    name=Git,
    text=Git,
    sort=git,
    description={Software di controllo versione distribuito utilizzabile da interfaccia a riga di comando. Rispetto a Git è meno flessibile, lievemente più lento ma con comandi più intuitivi e semplici da imparare}
}

\newglossaryentry{mercurial}
{
    name=Mercurial,
    text=Mercurial,
    sort=mercurial,
    description={Software di controllo versione distribuito utilizzabile da interfaccia a riga di comando. È uno dei pù diffusi strumenti di controllo versione}
}

\newglossaryentry{mod-incr}
{
    name=Modello incrementale,
    text=modello incrementale,
    sort=modello incrementale,
    description={In ingegneria del software, è una metodologia di sviluppo software in cui il cliente identifica, a grandi linee, i requisiti fondamentali e quelli desiderabili del prodotto software che vuole ottenere; viene poi deciso il numero di incrementi da effettuare, tenendo conto del fatto che ogni singolo incremento costituisce un sottoinsieme delle funzionalità del prodotto software. Una volta che gli incrementi sono stati identificati, si definiscono in dettaglio i requisiti che devono essere soddisfatti dagli incrementi prima di procedere allo sviluppo}
}

\newglossaryentry{agile}
{
    name=Agile,
    text=agile,
    sort=agile,
    description={In ingegneria del software, è un insieme di metodi di sviluppo del software emersi a partire dai primi anni 2000 e fondati su insieme di principi comuni, direttamente o indirettamente derivati dai principi del \textit{Manifesto per lo sviluppo agile del software} \cite{manifesto}. Tale manifesto si può riassumere in quattro punti:
        \begin{enumerate}
            \item le persone e le interazioni sono più importanti dei processi e degli strumenti;
            \item è più importante avere software funzionante che documentazione;
            \item bisogna collaborare con i clienti oltre che rispettare il contratto;
            \item bisogna essere pronti a rispondere ai cambiamenti oltre che aderire alla pianificazione.
        \end{enumerate}
    Un esempio di metodo di sviluppo di tipo agile è il metodo \emph{\gls{scrum}}\glsfirstoccur}
}

\newglossaryentry{scrum}
{
    name=Scrum,
    text=scrum,
    sort=scrum,
    description={Metodo di sviluppo software che rientra fra i metodi agile. Prevede di dividere il progetto in blocchi rapidi di lavoro (Sprint) alla fine di ciascuno dei quali creare un incremento del software. Esso indica come definire i dettagli del lavoro da fare nell'immediato futuro e prevede vari meeting con caratteristiche precise per creare occasioni di ispezione e controllo del lavoro svolto}
}

\newglossaryentry{milestone}
{
    name=Milestone,
    text=milestones,
    sort=milestone,
    description={Traguardi intermedi ed importanti nello svolgimento di un progetto; sono spesso fissati in fase di pianificazione}
}

\newglossaryentry{gantt}
{
    name=Diagramma di Gantt,
    text=diagramma di Gantt,
    sort=diagramma,
    description={Tipo di diagrammi molto usato per le attività di amministrazione di progetti poiché
        permettono una rappresentazione visuale di facile comprensione della durata delle attività
        che verranno svolte e le loro dipendenze. I Diagrammi di Gantt sono molto importanti
        per la gestione delle risorse di un progetto e per la creazione di un calendario delle attività
        che sia efficace}
}

\newglossaryentry{bus-logic}
{
    name=Business logic,
    text=business logic,
    sort=business logic,
    description={L'espressione logica di business (en. \textit{business logic}) si riferisce a tutta la logica applicativa che rende operativa un'applicazione. Con tale nome ci si riferisce quindi all'algoritmica che gestisce lo scambio di informazioni tra una sorgente dati e l'interfaccia utente attraverso la logica di presentazione e le elaborazioni intermedie sui dati estratti
}}

\newglossaryentry{arch-ntier}
{
    name=Architettura multi-tier,
    text=architettura multi-tier,
    sort=architettura multi-tier,
    description={In ingegneria del software, indica un'architettura software in cui le varie funzionalità del software sono logicamente separate e suddivise in più strati (\textit{tier}) in comunicazione fra loro. L'impiego più diffuso di un'architettura multi-tier è l'\emph{\gls{arch-3tier}}\glsfirstoccur   
}}

\newglossaryentry{arch-3tier}
{
    name=Architettura three-tier,
    text=architettura three-tier,
    sort=architettura three-tier,
    description={Questa architettura software è costruita su tre livelli:
        \begin{itemize}
            \item livello di presentazione: è il livello più alto, 
            \item livello applicazione, o \textit{business logic}:
            \item livello dati:
        \end{itemize}
}}

\newglossaryentry{design}
{
    name=Design pattern,
    text=design pattern,
    sort=design,
    description={In informatica, per Design Pattern si intende un modello logico che rappresenta una soluzione progettuale generale ad un problema ricorrente. Durante le fasi di progettazione del software può essere utile applicare uno di questi modelli logici per risolvere un particolare problema che può presentarsi in più di una situazione
}}

\newglossaryentry{xls}
{
    name=XLS,
    text=XLS,
    sort=xls,
    description={I file XLS sono fogli di calcolo creati con Microsoft Excel, la cui estensione è, per l'appunto, \textit{.xls}
}}

\newglossaryentry{scatter}
{
    name=Scatter Search,
    text=Scatter Search,
    sort=scatter,
    description={La Scatter Search è una tecnica meta-euristica utilizzata per la soluzione di numerosi problemi di ottimizzazione, tra cui problemi di scheduling. Essa consiste nel mantenere un insieme di soluzioni candidate di buona qualità e molto diverse fra loro per poi ricombinarle linearmente per creare soluzioni migliori
}}

\newglossaryentry{variable}
{
    name=Variable Neighbourhood Search,
    text=Variable Neighbourhood Search,
    sort=variable,
    description={La Variable Neighbourhood Search è una tecnica meta-euristica utilizzata per la soluzione di numerosi problemi di ottimizzazione, tra cui problemi di scheduling. Essa consiste di due fasi: nella prima fase, trova una soluzione che costituisca un ottimo locale; nella seconda, perturba tale soluzione per cambiare ``neighbourhood'' e scappare dall'ottimo individuato. Da questa soluzione trova un ulteriore ottimo locale e lo confronta con quello precedentemente trovato; se esso è migliorante, la Variable Neighbourhood Search comincia a esplorare il suo neighbourhood, altrimenti continua ad esplorare il precedente 
}}


